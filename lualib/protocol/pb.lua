
--[[
* File:        pb.lua
* Author:      shineflag
* Date :       2017-09-28
* Description: woyao protocol 的包装
* History：
	v0.0.1 增加 wy协议 每次使用都生成一个单独的table
]]

local pb = {}


local sendmap = {
	[0] = 	0x80,0x98,0xF7,0x19,0x65,0x14,0x3D,0x52,0xD7,0xB2,0xD1,0x8F,0x72,0x26,0xE2,0x53,
			0x25,0xA4,0x12,0x7B,0xD5,0xF4,0x40,0xCE,0x82,0x3F,0xAE,0xDC,0x92,0xA0,0x16,0x43,
			0xBB,0x48,0xF5,0x62,0x73,0x23,0xA8,0xB9,0x7A,0xCF,0xCD,0xBA,0x86,0x5D,0x57,0x5A,
			0x2C,0x7F,0x47,0x2D,0xE3,0xE0,0xBD,0x15,0xF3,0x9B,0x0D,0xE6,0x7C,0x4B,0x2B,0x6E,
			0xC2,0x75,0x6B,0xC5,0xAF,0xFB,0x21,0x96,0x67,0xA5,0xEC,0x79,0x9D,0x7D,0xB6,0x0C,
			0xF9,0x17,0xFC,0xBE,0x6A,0xC7,0x4E,0x4F,0x94,0x56,0x0A,0x46,0x3E,0xC3,0x9C,0x51,
			0xFE,0xC6,0xF2,0x20,0x54,0xB1,0xDD,0x03,0x42,0xA3,0xE1,0x06,0x88,0x74,0xFD,0x05,
			0x2F,0x5C,0x85,0xEF,0x34,0x4D,0xF8,0xDA,0x45,0xA6,0x29,0x59,0xED,0x1D,0xA9,0x61,
			0x81,0xB3,0x02,0xAB,0xC4,0x32,0x07,0x1F,0x8A,0x8D,0xDE,0x64,0x1C,0x49,0x37,0xCB,
			0x50,0x58,0x41,0xB5,0x76,0xE8,0x71,0x87,0xEA,0x1B,0xE5,0x91,0x24,0xD8,0x6F,0x5B,
			0xD6,0x5F,0xB0,0xCA,0xE7,0x90,0xFF,0x00,0x93,0x97,0xEE,0x9A,0xC1,0xB8,0xDF,0xF0,
			0x18,0x8B,0x8C,0x89,0x69,0xB7,0x09,0xCC,0xC9,0x78,0x70,0x35,0x13,0x9E,0x8E,0x08,
			0x39,0xAA,0xC0,0x0E,0x31,0x84,0xF1,0xBF,0x83,0x01,0x66,0x1E,0x36,0xBC,0x99,0x63,
			0x3A,0x7E,0x33,0x95,0x3B,0xA2,0xA7,0xDB,0x77,0x27,0xE9,0xAC,0x4C,0xEB,0x04,0xAD,
			0x2A,0x4A,0x3C,0x0B,0xFA,0xD3,0x6D,0x28,0xF6,0xD0,0xD9,0xE4,0xC8,0x68,0x22,0x30,
			0x44,0x11,0x2E,0xA1,0x0F,0x1A,0xB4,0x10,0x60,0x9F,0xD2,0x38,0x55,0x5E,0x6C,0xD4
}			



local recvmap = {
	[0] = 	0xA7,0xC9,0x82,0x67,0xDE,0x6F,0x6B,0x86,0xBF,0xB6,0x5A,0xE3,0x4F,0x3A,0xC3,0xF4,
			0xF7,0xF1,0x12,0xBC,0x05,0x37,0x1E,0x51,0xB0,0x03,0xF5,0x99,0x8C,0x7D,0xCB,0x87,
			0x63,0x46,0xEE,0x25,0x9C,0x10,0x0D,0xD9,0xE7,0x7A,0xE0,0x3E,0x30,0x33,0xF2,0x70,
			0xEF,0xC4,0x85,0xD2,0x74,0xBB,0xCC,0x8E,0xFB,0xC0,0xD0,0xD4,0xE2,0x06,0x5C,0x19,
			0x16,0x92,0x68,0x1F,0xF0,0x78,0x5B,0x32,0x21,0x8D,0xE1,0x3D,0xDC,0x75,0x56,0x57,
			0x90,0x5F,0x07,0x0F,0x64,0xFC,0x59,0x2E,0x91,0x7B,0x2F,0x9F,0x71,0x2D,0xFD,0xA1,
			0xF8,0x7F,0x23,0xCF,0x8B,0x04,0xCA,0x48,0xED,0xB4,0x54,0x42,0xFE,0xE6,0x3F,0x9E,
			0xBA,0x96,0x0C,0x24,0x6D,0x41,0x94,0xD8,0xB9,0x4B,0x28,0x13,0x3C,0x4D,0xD1,0x31,
			0x00,0x80,0x18,0xC8,0xC5,0x72,0x2C,0x97,0x6C,0xB3,0x88,0xB1,0xB2,0x89,0xBE,0x0B,
			0xA5,0x9B,0x1C,0xA8,0x58,0xD3,0x47,0xA9,0x01,0xCE,0xAB,0x39,0x5E,0x4C,0xBD,0xF9,
			0x1D,0xF3,0xD5,0x69,0x11,0x49,0x79,0xD6,0x26,0x7E,0xC1,0x83,0xDB,0xDF,0x1A,0x44,
			0xA2,0x65,0x09,0x81,0xF6,0x93,0x4E,0xB5,0xAD,0x27,0x2B,0x20,0xCD,0x36,0x53,0xC7,
			0xC2,0xAC,0x40,0x5D,0x84,0x43,0x61,0x55,0xEC,0xB8,0xA3,0x8F,0xB7,0x2A,0x17,0x29,
			0xE9,0x0A,0xFA,0xE5,0xFF,0x14,0xA0,0x08,0x9D,0xEA,0x77,0xD7,0x1B,0x66,0x8A,0xAE,
			0x35,0x6A,0x0E,0x34,0xEB,0x9A,0x3B,0xA4,0x95,0xDA,0x98,0xDD,0x4A,0x7C,0xAA,0x73,
			0xAF,0xC6,0x62,0x38,0x15,0x22,0xE8,0x02,0x76,0x50,0xE4,0x45,0x52,0x6E,0x60,0xA6
}

--[[
#pragma pack(1)
struct YYPkgHeader
{	
	int    length;
	char  flag[2];
	int    cmd;
	char  code;
 
};
#pragma pack()
--]]
local function create_wy()
	local pwoyao = {}
	local BODY_BEGIN = 8

	local cmd 
	local buffer
	local gameid
	local len
	local rpos

	local head 
	local body

	--将二进制数据解成可读的包
	local function unpack(data,lenght)
		buffer = data
		cmd = string.unpack("!1>I4",data, 3)
		len = lenght or #data
		rpos = BODY_BEGIN

		--print("unpack",lenght, buffer)
	end

	--返回打包（4位长度+包体）的数据(在发送之前打包)
	local function pack( )

		local slen = string.pack("!1>i4",string.len(buffer) + 4)
		buffer = slen .. buffer
		-- buffer = string.pack("!1>s4",buffer)
		return buffer
	end

	--加密
	--在write_end()之后 pack() 之前调用
	local function encrypt( )
		--打包的时候，在buffer前加个4个字节的长度

		local t = {}
		local checkcode = 0
		for k,v in pairs({string.byte(buffer,BODY_BEGIN,-1) }) do
			checkcode = checkcode + v
			t[k] = sendmap[v]

		end
		local encrypt_body = string.char(table.unpack(t))

		local checkcode = (~checkcode+1) & 0xff
		local encrypt_head = (string.sub(buffer,1,BODY_BEGIN-2)) ..  string.char(checkcode)
		--print("encrypt:" , #encrypt_head, #encrypt_body,#t)
		buffer = encrypt_head .. encrypt_body

	end


	--解密
	--在upack 之后
	local function decrypt()
		local checkcode = buffer:byte(BODY_BEGIN-1)
		local t = {}
		for k,v in pairs({string.byte(buffer,BODY_BEGIN,-1)}) do
			t[k] = recvmap[v]
			checkcode = checkcode + t[k]
		end
		local decrypt_body = string.char(table.unpack(t))
		buffer = (string.sub(buffer,1,BODY_BEGIN-1)) .. decrypt_body

		return checkcode
	end


	local function get_cmd(  )
		return cmd
	end


	local function  read_byte()
		if rpos > len then
			return false;
		end
		local num = buffer:byte(rpos)
		rpos = rpos +  1
		return num
	end

	local function read_short()
		if rpos > len then
			return false;
		end
		local num = string.unpack("!1>i2", buffer, rpos)
		rpos = rpos +  2
		return num
	end


	local function read_int()
		if rpos > len then
			return false;
		end
		local num = string.unpack("!1>i4", buffer, rpos)
		rpos = rpos +  4
		return num
	end

	local function read_int64()
		if rpos > len then
			return false;
		end
		local num = string.unpack("!1>i8", buffer, rpos)
		rpos = rpos +  8
		return num
	end

	local function read_string()
		local sz = read_int()
		--string end has '\0'
		if not sz or sz < 1 then
			return ""
		end

		local str = buffer:sub(rpos, rpos + sz -2)
		rpos = rpos +  sz
		return str
	end

	local function read_binary()
		local sz = read_int()
		if not sz or rpos + sz > len + 1 then 
			return nil,0
		end

		local bin = buffer:sub(rpos, rpos+sz-1)
		rpos = rpos + sz
		return bin,sz
	end


	local function write_byte( b )
		if type(b) == "string" then
			b = b:byte(1)
		end
		local str = string.char(b)--string.pack("!1>b",b)
		table.insert(body,str)
	end

	local function write_short( s )
		local str = string.pack("!1>i2",s)
		table.insert(body,str)
	end

	local function write_int( i )
		local str = string.pack("!1>i4",i)
		table.insert(body,str)
	end

	local function write_int64( i64 )
		local str = string.pack("!1>i8",i64)
		table.insert(body,str)
	end

	local function write_string( str )
		local str = string.pack("!1>s4",str .. "\0")
		table.insert(body,str)
	end

	local function write_binary( bin )
		local b = string.pack("!1>s4",bin)
		table.insert(body,b)
	end


	local function write_begin( command )
		cmd = command
		local flag = "HZ"
		local cmd_str = string.pack("!1>i4",cmd)
		local code = string.char(0)

	     --
	    head = flag .. cmd_str ..  code
	    --print("write_begin",#head,head)
	    body = {}
	end

	local function write_end( )
		buffer = head .. table.concat(body)
		--print("write_end",#buffer,buffer)
	end


	pwoyao.unpack = unpack
	pwoyao.pack = pack

	pwoyao.encrypt = encrypt
	pwoyao.decrypt = decrypt

	pwoyao.get_cmd = get_cmd

	pwoyao.read_byte = read_byte
	pwoyao.read_short = read_short
	pwoyao.read_int = read_int
	pwoyao.read_int64 = read_int64
	pwoyao.read_string = read_string
	pwoyao.read_binary = read_binary


	pwoyao.write_byte = write_byte
	pwoyao.write_short = write_short
	pwoyao.write_int = write_int
	pwoyao.write_int64 = write_int64
	pwoyao.write_string = write_string
	pwoyao.write_binary = write_binary
	pwoyao.write_begin= write_begin
	pwoyao.write_end = write_end

	return pwoyao

end



--根据信息自动解释成相应的协议
local function unpack( msg,size )
	local pkg
	local index = string.find(msg,"HZ",1,true)
	if index == 1 then
		pkg = create_wy()
		pkg.unpack(msg,size)
		--log.d(TAG,string.format("cmd[0x%x] is qe protocol",pkg.get_cmd()))
	else
		log.e(TAG)
	end
	return pkg
end

pb.create_wy = create_wy
pb.unpack = unpack


return pb


